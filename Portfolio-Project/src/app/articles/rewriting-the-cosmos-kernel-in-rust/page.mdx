import {ArticleLayout} from '@/components/ArticleLayout'

export const article = {
    author: 'Polo Vargas',
    date: '2025-09-15',
    title: 'SQL and NoSQL through hands-on experiments',
    description:
        'Relational or document-based? In this article, I explore the key differences between SQL and NoSQL through hands-on experiments, and how each plays a role in building efficient, scalable data systems.',
}

export const metadata = {
    title: article.title,
    description: article.description,
}

export default (props) => <ArticleLayout article={article} {...props} />

When I first started modeling real-world data, I thought choosing between SQL and NoSQL was just a matter of preference — kind of like tabs vs. spaces. But the deeper I got into data modeling, the more I realized it’s not a debate about technology. It’s about understanding how real life behaves — unpredictable, messy, and full of exceptions that don’t fit cleanly into any schema.

At first, I lived in the SQL world. Tables, foreign keys, and constraints made sense to me. SQL gave me structure, and structure gave me confidence. You can write a query once and trust it will behave tomorrow exactly as it did today. When I was working on projects involving trades, orders, and financial instruments, relational databases were the perfect match. The data was structured, relationships were predictable, and ACID transactions gave me peace of mind.

I loved how SQL forces discipline. It makes you think carefully about relationships before you write a single line of data. You define your schema, and your schema defines how the system thinks. It’s logical, traceable, and, for better or worse, unforgiving.

Then came my first NoSQL project, and everything changed.

I was trying to store event logs — real user actions that changed shape over time. Some events had five properties, others had fifteen, and occasionally, a new one appeared that broke everything I thought I knew about the dataset. Trying to force that data into a fixed SQL schema felt like hammering a square peg into a round hole.

So I turned to NoSQL, and suddenly the world felt flexible. Collections, documents, nested objects — it was liberating. I could store data as it came, adapt my model on the fly, and stop worrying about migrations every time the product team added a new feature.

But that flexibility had a cost. Without a schema, consistency became my responsibility. I had to make sure the data followed the right patterns manually, because the database wasn’t enforcing them for me. I learned that schema-less doesn’t mean structureless — it means you are the schema.

After working with both, here’s what I learned:

SQL: The Architect

SQL is great when your data is well-behaved and your rules are clear. It gives you tools for validation, transactions, and data integrity — perfect for systems where every record matters. If you’re dealing with structured relationships, historical tracking, or data that doesn’t change format frequently, SQL is still king. It’s reliable, predictable, and battle-tested.

NoSQL: The Explorer

NoSQL shines in chaos. It’s built for when your data changes faster than your schema can keep up — user-generated content, logs, IoT events, or anything unstructured. It lets you move fast, test ideas, and scale without constantly redefining tables. But it also demands discipline: good naming conventions, versioning strategies, and strong data validation at the application level.

Where I Landed

After working with both for a while, I stopped seeing SQL vs NoSQL as a war and started seeing them as complementary tools. I’ve used SQL for structure — the parts of my systems that need to be consistent and auditable — and NoSQL for flexibility, especially when modeling behavior or capturing unpredictable events.

The real lesson? Databases are just mirrors of the world you’re modeling. And the real world isn’t perfectly relational or purely document-based — it’s a mix of both.

SQL is the architect that builds stable structures.
NoSQL is the explorer that maps uncharted territory.
Real-world data needs both.
